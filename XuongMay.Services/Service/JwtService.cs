using GarmentFactory.Contract.Repositories.Entity;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using XuongMay.Contract.Repositories.Interface;
using XuongMay.Contract.Services.Interface;
using XuongMay.Core.Utils;
using XuongMay.ModelViews.JwtModelViews;
using static XuongMay.Core.Base.BaseException;

namespace XuongMay.Services.Service
{
    public class JwtService : IJwtService
	{
		private readonly IConfiguration _config;
		private readonly IUnitOfWork _unitOfWork;

		public JwtService(IConfiguration config, IUnitOfWork unitOfWork)
		{
				_config = config;
				_unitOfWork = unitOfWork;
				
		}

		/// <summary>
		/// Generate access token with claims (user's informations)
		/// </summary>
		/// <param name="claims">A list of Claim having user information</param>
		/// <returns>A string of token which generated by Claim list</returns>
		private string GenerateAccessToken(IEnumerable<Claim> claims)
		{
			int expireMinutes = 60; //set default expire time is 60 minutes

			//get secret key from appsettings.json
			var secretKey = _config.GetSection("Jwt:SecretKey").Value;

			//convert secret key to byte array
			var symmetricKey = Encoding.UTF8.GetBytes(secretKey);

			//create token with JwtSecurityTokenHandler
			var tokenHandler = new JwtSecurityTokenHandler();

			var tokenDescriptor = new JwtSecurityToken(
				issuer: "https://localhost:7286/", //set issuer is localhost

				audience: "https://localhost:7286/", //set audience is localhost

				claims: claims,

				expires: CoreHelper.SystemTimeNows.Add(TimeSpan.FromMinutes(expireMinutes)),

				signingCredentials: new SigningCredentials(
									new SymmetricSecurityKey(symmetricKey),
									SecurityAlgorithms.HmacSha256Signature) //use HmacSha256Signature algorithm to sign token
			);
			//write token with tokenDescriptor above
			var token = tokenHandler.WriteToken(tokenDescriptor);
			return token;
		}

		/// <summary>
		/// Refresh access token for expired token
		/// </summary>
		/// <returns></returns>
		private string GenerateRefreshToken()
		{
			//generate random number for refresh token
			var randomNumber = new byte[32];

			//use RandomNumberGenerator to create random number
			using(var rng = RandomNumberGenerator.Create())
			{
				//get random number and convert to base64 string
				rng.GetBytes(randomNumber);
				return Convert.ToBase64String(randomNumber);
			}
		}

		/// <summary>
		/// Method get all Claim with related user 
		/// </summary>
		/// <param name="token"></param>
		/// <returns></returns>
		/// <exception cref="SecurityTokenException"></exception>
		private ClaimsPrincipal GetPrincipalFromExpiredToken(string token)
		{
			//set token validation parameters
			TokenValidationParameters tokenValidationParameters = new()
			{
				ValidateAudience = false,

				ValidateIssuer = false,

				ValidateIssuerSigningKey = true,

				IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config.GetSection("Jwt:SecretKey").Value)), //Sign with encoded secret key

				ValidateLifetime = false //this field not need to check validate because we just want to get principal from that token
			};

			//get principal from token from tokenValidationParameters (information Claim in here)
			var tokenHandler = new JwtSecurityTokenHandler();
			SecurityToken securityToken;
			var principal = tokenHandler.ValidateToken(token, tokenValidationParameters, out securityToken);
			var jwtSecurityToken = securityToken as JwtSecurityToken;

			//check if token is null or not and compare algorithm
			if (jwtSecurityToken == null || !jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256Signature, StringComparison.InvariantCultureIgnoreCase))
			{
				//throw exception if information in token is invalid
				throw new SecurityTokenException("Invalid token");
			}
			return principal;
		}


		/// <summary>
		/// Generate token Method in Service for API
		/// </summary>
		/// <param name="claims"></param>
		/// <param name="Id"></param>
		/// <param name="accessToken"></param>
		/// <param name="refreshToken"></param>
		public void GenerateAccessToken(IEnumerable<Claim> claims, int Id, out string accessToken, out string refreshToken)
		{
			//generate access token and refresh token
			accessToken = GenerateAccessToken(claims);

			refreshToken = GenerateRefreshToken();

			//get user by Id
			var user = _unitOfWork.GetRepository<User>().GetById(Id);

			//set refresh token, expirytime for refreshtoken to user and save to database
			user.RefreshToken = refreshToken;

			user.RefreshTokenExpiryTime = CoreHelper.SystemTimeNows.AddMinutes(10);

			//save to database
			_unitOfWork.GetRepository<User>().Save();
		}

		/// <summary>
		/// Revoke token Method in Service for API
		/// </summary>
		/// <param name="Id"></param>
		/// <exception cref="ErrorException"></exception>
		public void RevokeToken(string Id)
		{
			var user = _unitOfWork.GetRepository<User>().GetById(Int32.Parse(Id)) ?? throw new ErrorException(StatusCodes.Status400BadRequest, new ErrorDetail() { ErrorMessage = "Can not find available user!" });
			user.RefreshToken = null; //delete refresh token in DB

			_unitOfWork.GetRepository<User>().Save(); // write changes to database
		}


		/// <summary>
		/// Refresh token Method in Service for API
		/// </summary>
		/// <param name="newAccessToken"></param>
		/// <param name="newRefreshToken"></param>
		/// <param name="tokenApiModel"></param>
		/// <exception cref="ErrorException"></exception>
		public void RefreshAccessToken(out string newAccessToken, out string newRefreshToken, TokenApiModelView tokenApiModel)
		{
			//Check if tokenApiModel is null or not
			tokenApiModel = tokenApiModel ?? throw new ErrorException(StatusCodes.Status400BadRequest, new ErrorDetail() { ErrorMessage = "Please fill all of information!" });

			string accessToken = tokenApiModel.AccessToken;
			string refreshToken = tokenApiModel.RefreshToken;

			var principal = GetPrincipalFromExpiredToken(tokenApiModel.AccessToken);

			string Id = principal.Identity.Name; //this is mapped to the Name claim by default

			//get user 
			var user = _unitOfWork.GetRepository<User>().GetById(Int32.Parse(Id))
														?? throw new ErrorException(StatusCodes.Status404NotFound, new ErrorDetail()
														{ ErrorMessage = "The user is not found" });

			//check valid for refresh token and expiry time
			if ( user.RefreshToken == null || user.RefreshToken != refreshToken || user.RefreshTokenExpiryTime <= CoreHelper.SystemTimeNows)
			{
				throw new ErrorException(StatusCodes.Status400BadRequest, new ErrorDetail() { ErrorMessage = "Refresh token is incorrect or user is invalid!" });
			}

			//generate new access token and refresh token
			newAccessToken = GenerateAccessToken(principal.Claims);
			newRefreshToken = GenerateRefreshToken();

			//set new refresh token to user and save to database
			user.RefreshToken = newRefreshToken;
			_unitOfWork.GetRepository<User>().Save();
		}


	}
}
